---
title: Die Grundlagen von Java Threads
description: In Vorbereitung auf die Aufnahmeprüfung für das Informatik Studium, habe ich diesen Blog Post geschrieben, in dem die Grundlagen von Java Threads erklärt werden.
thumbnail: thumbnail.jpg
publishedOn: null
---

# Threaderzeugung

Es gibt zwei Möglichkeiten einen Thread zu erzeugen:

- Implementieren des Interfaces `java.lang.Runnable`
- Ableiten der Klasse `java.lang.Thread`

## Implementieren von `Runnable`

Das Interface `java.lang.Runnable` hat folgenden Aufbau:

```java
public interface Runnable {
  void run();
}
```

Zum Erzeugen eines Threads, der auf dem Interface `Runnable` basiert sind folgende Schritte nötig:

1. Eine Klasse implementiert das Interface `Runnable` und konkretisiert die Methode `run()`. Diese Methode wird abgearbeitet, wenn der Thread gestartet wird.
2. Ein Objekt der Klasse `java.lang.Thread` wird instanziiert. Dem Konstruktor wird eine Instanz jener Klasse übergeben, die das Interface `Runnable` implementiert.
3. Die Methode `start()` der Klasse `java.lang.Thread` wird für das eben erzeugte Threadobjekt aufgerufen. Diese Methode versetzt den Thread in einen Zustand, der es ihm ermöglicht, seine Methode `run()` auszuführen. Dies muss nicht sofort erfolgen, da unter Umständen andere Threads zuerst ausgeführt werden.

## Ableiten der Klasse `Thread`

Auch hier erfolgt die Threaderzeugung in 3 Schritten:

1. Eine Klasse wird von Thread abgeleitet und die Methode `run()` wird überschrieben.
2. Ein Objekt dieser neuen Klasse wird angelegt.
3. Die von Thread geerbte Methode `start()` wird für das eben erzeugte Threadobjekt aufgerufen. Diese Methode versetzt den Thread in einen Zustand, der es ihm ermöglicht, seine Methode `run()` in einem eigenen Thread auszuführen.

# Threadzustände

Die folgende Abbildung gibt einen Überblick über die Zustände die ein Thread durchlebt:

![Threadzustände](/images/blog/posts/the-basics-of-java-threads/Threadzustaende.png)

## Die Zustände _ready_ und _running_

Nach dem Start wird der Thread in den Zustand _ready_ versetzt. In diesem Zustand wartet er darauf, dass ihm der Threadscheduler die CPU zuteilt. Geschieht dies, so geht er in den Zustand _running_ über. Diese beiden Zustände heißen auch aktive Threadzustände (_active_). Während ein Thread die Methode `run()` abarbeitet, wird er in der Regel mehrmals voom Threadscheduler zwischen den Zuständen _running_ und _ready_ hin- und hergeschaltet. Er kann auch mithilfe der statischen Methode `Thread.yield()` von selbst anbieten, vom _running_-Status in den _ready_-Status zu wechseln. Ob dies tatsächlich geschieht, ist betriebssystemabhänging.

## Der Zustand _dead_

Wenn der Thread seine Methode `run()` abgearbeitet hat, so kommt er in den Zustand _dead_. Diesen Zustand kann er nicht mehr verlassen, d. h. der Thread kann kein zweites Mal gestartet werden.

## Der Zustand _sleeping_

Der Zustand _sleeping_ kann z. B. durch die statische Methode `sleep(long millis)` erreicht werden. Diese Methode versetzt den laufenden Thread für die angegebene Zeit in diesen Zustand. Danach geht er wieder in den Zustand _ready_ über. Wird für einen schlafenden Thread die Methode `interrupt()` aufgerufen, so geht er vor Ablauf der angegebenen Zeit wieder in den Zustand _ready_ über. Die Methode `sleep()` wirft in diesem Fall eine `InterruptedException`.

## Der Zustand _blocked_

Ein Thread, der mit Dateiein-/ausgabe beschäftigt ist, muss in der Regell auf nicht bereite I/O-Geräte warten. In diesem Fall wird er automatisch in den Zustand _blocked_ versetzt. Er kommt erst dann wieder in den Zustand _ready_, wenn die I/O-Operation beendet ist.

Außerdem kann sich ein Thread mithilfe der Instanzmethode `join()` auch selbst in den Zustand _blocked_ versetzen. Er wartet dann, bis jener Thread, für den er die Methode `join()` aufgerufen hat, den Zustand _dead_ erreicht hat. Mithilfe dieser Technik kann der aktuelle Thread also warten, bis ein anderer Thread fertig gearbeitet hat.

# Die Klasse `java.lang.Thread`

## Konstruktoren

```java
public Thread()
public Thread(Runnable target)
public Thread(String name)
public Thread(Runnable target, String name)
```

## Wichtige Methoden

```java
public static Thread currentThread()
```

Liefert eine Referenz auf den CurrentThread, das ist jener Thread, der diesen Befehlt gerade abarbeitet.

```java
public static void sleep(long millis) throws InterruptedException
```

Versetzt den CurrentThread für `millis` Millisekunden in den Zustand _sleeping_. Es ist auch die überladene Methode `sleep(long millis, int nanos)` verfügbar. Mithilfe von `interrupt()` kann der schlafende Thread vorzeitig in den Zustand active versetzt werden.

# Threadsynchronisation

## Problemstellung

Haben mehrere Threads konkurrierenden Zugriff auf ein und dasselbe Objekt, so ist sicherzustellen, dass sie sich nicht gegenseitig Variablen überschreiben. Sehr oft ist es notwendig, dass ein Thread einen bestimmten Codeabschnitt fertig abarbeitet, bevor ein anderer Thread Zugriff auf diesen Codeabschnitt bekommt (man spricht auch von atomaren Operationen). Dabei ist zu beachten:

- Alle Threads haben gemeinsamen (konkurrierenden) Zugriff auf den Heap, d. h. Objekte und Arrays sind nicht threadsicher und man hat sich als Entwickler selbst um die Threadsicherheit (Synchronisation) zu kümmern.
- Jeder Thread betreibt seinen eigenen Stack, d. h. lokale Variablen sind im Wesentlichen threadsicher.

## Mutex

### Charakteristika

- Ein Mutex Lock (**mut**ual **ex**clusion lock, auch einfach Mutex oder Lock genannt), sorgt dafür, dass zu einem bestimmten Zeitpunkt nur ein Thread einen definierten Codeabschnitt (kritischer Bereich) abarbeiten kann.
- Ein Thread kann sich nicht selbst mit einem Mutex blockieren (d. h. er kann ohne Probleme die Sperre ein zweites mal bekommen, auch wenn er die Sperre noch hält).<br />Will ein Thread einen Mutex erwerben und ist er bereits Besitzer des Mutex, wird ein interner Zähler erhöht, der Thread jedoch nicht blockiert. Der Zähler dient dazu, den Mutex nur dann freizugeben, wenn der besitzende Thread für jede erhaltene Sperre auch eine Freigabe durchführt.

- Ein Mutex kann nur von dem Thread freigegeben werden, der den Mutex erworben hat.

## Object Locking

Das Mutexkonzept ist in Java mithilfe des Schlüsselwortes `synchronized` über das Prinzip des Object-Locking umgesetzt. Jedem Mutex kann dabei ein beliebiges Javaobjekt zugeordnet werden, das die Sperre repräsentiert (diese Eigenschaft ist bereits in `java.lang.Object` implementiert). Es gibt drei Möglichkeiten, um Javacode für ein bestimmtes Objekt zu einem Mutex zu machen:

1.  Synchronisation einer Instanzmethode. Die Methode erhält den Modifier `synchronized` und als Sperrobjekt wird das `this`-Objekt verwendet:

    ```java
    public synchronized boolean test(int j) {
      this.i = j;
      return this.i == j;
    }
    ```

2.  Synchronisieren einer Klassenmethode (statischen Methode). Die Methode erhält den Modifier `synchronized`. Dabei wird das Klassenobjekt gesperrt. Der angeforderte Monitor ist dabei also ein klassenbezogener Monitor, der den Zugriff auf alle synchronisierten `static`-Methoden dieser Klasse regelt. Zu jedem Zeitpunkt kann also maximal ein Thread die synchronisierten `static`-Methoden einer Klasse abarbeiten.

3.  Synchronisieren eines Blocks. Mithilfe synchronisierter Blöcke kann beliebiger Javacode für ein bestimmtes Objekt als Monitor definiert werden. Dabei sollte die Referenz `<object reference>` final sein, damit sichergestellt ist, dass die Referenz während der Abarbeitung des Mutex nicht verbogen werden kann.

    Syntax:

    ```java
    synchronized (<object reference>) {<code block>}
    ```

    Arrays können nur mithilfe dieser Technik synchronisiert werden, da sie als klassenlose Objekte keine Instanzmethoden besitzen:

    ```java
    final byte[] a;

    synchronized (a) {
      java.util.Arrays.sort(a);
    }
    ```

## Synchronisation und Kommunikation

Das Problem der Synchronisation ist eng mit dem Problem der Kommunikation von Threads verbunden. Der folgende Ablauf zeigt eine typische Situation:

|     | Thread A                                                        | Thread B                        |
| --- | --------------------------------------------------------------- | ------------------------------- |
| 1   | Initialisierung, Problem wird in Teilprobleme aufgeteilt        | Initialisierung                 |
| 2   | Setzt Anfangsparameter für B                                    |                                 |
| 3   | Sendet Startsignal an B                                         | Empfängt Startsignal von A      |
| 4   | Rechnet                                                         | Rechnet                         |
| 5   | Wartet auf Ergebnis von B                                       | Rechnet                         |
| 6   | Empfängt Signal "Fertig" von B                                  | Sendet Signal "Fertig" an A     |
| 7   | Liest Ergebnis von B aus und kombiniert es mit eigenem Ergebnis | Wartet auf nächstes Startsignal |
